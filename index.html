<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Fidelity Xmas Tree - Strawberry Edition</title>
    <style>
        body { margin: 0; background: #010805; overflow: hidden; font-family: -apple-system, sans-serif; }
        #root { width: 100vw; height: 100vh; }
        .overlay {
            position: absolute; top: 8%; width: 100%; text-align: center;
            pointer-events: none; z-index: 10;
        }
        .overlay h1 { color: #FFFACD; text-shadow: 0 0 20px rgba(255,250,205,0.8); margin: 0; font-size: 28px; min-height: 1.2em; }
        .overlay p { color: white; opacity: 0.6; letter-spacing: 5px; font-size: 12px; margin-top: 10px; }
        .hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #C1E1C1; opacity: 0.5; font-size: 11px; letter-spacing: 2px; pointer-events: none;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom": "https://esm.sh/react-dom@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.88.15?external=react,react-dom,three,@react-three/fiber",
            "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.15.11?external=react,react-dom,three,@react-three/fiber"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div class="overlay">
        <h1 id="greeting"></h1>
        <p>MERRY CHRISTMAS</p>
    </div>
    <div id="root"></div>
    <div class="hint">点击触发粒子爆发 • 拖拽旋转视角</div>

    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Float, Stars, OrbitControls, PerspectiveCamera } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';

        const PALETTE = {
            trunk: '#3d2b1f',
            leafDark: '#0a2910',
            leafLight: '#165B33',
            strawberryRed: '#ff0800',
            strawberryLeaf: '#2d5a27',
            gold: '#FFD700',
            silver: '#E5E4E2',
            xmasRed: '#D42426',
            pink: '#FFB7B2',
            bg: '#010805'
        };

        // 打字机
        const Typewriter = () => {
            useEffect(() => {
                const text = "小羊同学，圣诞节快乐！爱你一万零一遍";
                let i = 0;
                const interval = setInterval(() => {
                    const el = document.getElementById('greeting');
                    if(el) el.innerText = text.slice(0, i);
                    i++;
                    if (i > text.length) clearInterval(interval);
                }, 150);
                return () => clearInterval(interval);
            }, []);
            return null;
        };

        // 高级草莓组件
        const Strawberry = ({ position }) => {
            const seedCount = 60;
            const seeds = useMemo(() => {
                const positions = [];
                for (let i = 0; i < seedCount; i++) {
                    const phi = Math.acos(-1 + (2 * i) / seedCount);
                    const theta = Math.sqrt(seedCount * Math.PI) * phi;
                    positions.push([
                        0.38 * Math.cos(theta) * Math.sin(phi),
                        0.45 * Math.sin(theta) * Math.sin(phi) - 0.1,
                        0.38 * Math.cos(phi)
                    ]);
                }
                return positions;
            }, []);

            return (
                <group position={position}>
                    {/* 草莓果实 */}
                    <mesh castShadow>
                        <sphereGeometry args={[0.5, 32, 32]} />
                        <meshStandardMaterial color={PALETTE.strawberryRed} roughness={0.3} metalness={0.1} />
                    </mesh>
                    {/* 草莓种子 */}
                    {seeds.map((pos, i) => (
                        <mesh key={i} position={pos}>
                            <sphereGeometry args={[0.015, 8, 8]} />
                            <meshBasicMaterial color="#111" />
                        </mesh>
                    ))}
                    {/* 草莓叶子 */}
                    <group position={[0, 0.4, 0]}>
                        {[0, 1, 2, 3, 4, 5].map((i) => (
                            <mesh key={i} rotation={[0, (i * Math.PI * 2) / 6, 0.8]}>
                                <coneGeometry args={[0.15, 0.5, 3]} />
                                <meshStandardMaterial color={PALETTE.strawberryLeaf} />
                            </mesh>
                        ))}
                    </group>
                    {/* 顶部光晕 */}
                    <pointLight intensity={15} distance={5} color={PALETTE.strawberryRed} />
                </group>
            );
        };

        // 层次感树体（多层松针效果）
        const LayeredTree = ({ isExploded }) => {
            const layers = 5;
            const groupRef = useRef();

            useFrame((state) => {
                if (isExploded) {
                    groupRef.current.position.y = THREE.MathUtils.lerp(groupRef.current.position.y, -20, 0.05);
                    groupRef.current.scale.setScalar(THREE.MathUtils.lerp(groupRef.current.scale.x, 0, 0.05));
                } else {
                    groupRef.current.position.y = THREE.MathUtils.lerp(groupRef.current.position.y, -4, 0.1);
                    groupRef.current.scale.setScalar(THREE.MathUtils.lerp(groupRef.current.scale.x, 1, 0.1));
                }
            });

            return (
                <group ref={groupRef} position={[0, -4, 0]}>
                    {/* 树干 */}
                    <mesh position={[0, 0.5, 0]}>
                        <cylinderGeometry args={[0.3, 0.5, 2, 12]} />
                        <meshStandardMaterial color={PALETTE.trunk} roughness={1} />
                    </mesh>
                    {/* 树层 */}
                    {[...Array(layers)].map((_, i) => (
                        <mesh key={i} position={[0, i * 1.8 + 1.5, 0]}>
                            <coneGeometry args={[(layers - i) * 1.2, 2.5, 8]} />
                            <meshStandardMaterial 
                                color={i % 2 === 0 ? PALETTE.leafDark : PALETTE.leafLight} 
                                flatShading={true}
                                roughness={0.8}
                            />
                        </mesh>
                    ))}
                </group>
            );
        };

        // 雪花
        const Snow = ({ count = 1000 }) => {
            const mesh = useRef();
            const particles = useMemo(() => {
                const pos = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    pos.set([(Math.random()-0.5)*30, Math.random()*25, (Math.random()-0.5)*30], i * 3);
                }
                return pos;
            }, [count]);

            useFrame(() => {
                const positions = mesh.current.geometry.attributes.position.array;
                for (let i = 0; i < count; i++) {
                    positions[i * 3 + 1] -= 0.03;
                    if (positions[i * 3 + 1] < -5) positions[i * 3 + 1] = 20;
                }
                mesh.current.geometry.attributes.position.needsUpdate = true;
            });

            return (
                <points ref={mesh}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={particles} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.06} color="#ffffff" transparent opacity={0.6} />
                </points>
            );
        };

        // 装饰球 (爆炸逻辑保留)
        const Orbs = ({ isExploded }) => {
            const meshRef = useRef();
            const dummy = new THREE.Object3D();
            const count = 40;
            const colors = [PALETTE.gold, PALETTE.silver, PALETTE.xmasRed, '#00A86B'];

            const data = useMemo(() => {
                return Array.from({ length: count }, () => {
                    const y = Math.random() * 8 - 2;
                    const r = (8 - y) * 0.35;
                    const a = Math.random() * Math.PI * 2;
                    const pos = new THREE.Vector3(Math.cos(a) * r, y, Math.sin(a) * r);
                    return {
                        base: pos.clone(),
                        current: pos.clone(),
                        vel: pos.clone().normalize().multiplyScalar(Math.random() * 12 + 8),
                        color: new THREE.Color(colors[Math.floor(Math.random() * colors.length)])
                    };
                });
            }, []);

            useFrame((state, delta) => {
                data.forEach((o, i) => {
                    if (isExploded) {
                        o.current.addScaledVector(o.vel, delta);
                    } else {
                        o.current.lerp(o.base, 0.1);
                    }
                    dummy.position.copy(o.current);
                    dummy.scale.setScalar(0.15);
                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i, dummy.matrix);
                    meshRef.current.setColorAt(i, o.color);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
                meshRef.current.instanceColor.needsUpdate = true;
            });

            return (
                <instancedMesh ref={meshRef} args={[new THREE.SphereGeometry(1, 24, 24), null, count]}>
                    <meshStandardMaterial metalness={0.9} roughness={0.1} />
                </instancedMesh>
            );
        };

        const App = () => {
            const [exploded, setExploded] = useState(false);

            return (
                <Canvas onClick={() => setExploded(!exploded)} shadows>
                    <Typewriter />
                    <PerspectiveCamera makeDefault position={[0, 2, 15]} fov={45} />
                    <OrbitControls enablePan={false} autoRotate={!exploded} autoRotateSpeed={0.5} minDistance={8} maxDistance={22} />
                    
                    <color attach="background" args={[PALETTE.bg]} />
                    <ambientLight intensity={0.4} />
                    <spotLight position={[10, 10, 10]} intensity={10} angle={0.3} penumbra={1} castShadow />
                    <pointLight position={[-5, 5, -5]} intensity={5} color={PALETTE.pink} />

                    <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade />
                    <Snow count={1000} />

                    {/* 主树体 */}
                    <LayeredTree isExploded={exploded} />
                    
                    {/* 装饰物 */}
                    <Orbs isExploded={exploded} />

                    {/* 顶部漂浮草莓 */}
                    <Float speed={2} rotationIntensity={1.5} floatIntensity={2}>
                        <Strawberry position={[0, 6.5, 0]} />
                    </Float>

                    {/* 后期特效 */}
                    <EffectComposer>
                        <Bloom luminanceThreshold={0.3} intensity={1.2} mipmapBlur radius={0.5} />
                        <Noise opacity={0.05} />
                        <Vignette offset={0.3} darkness={0.8} />
                    </EffectComposer>
                </Canvas>
            );
        };

        createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
