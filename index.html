<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xmas Tree - Rabbit & Strawberry</title>
    <style>
        body { margin: 0; background: #010403; overflow: hidden; font-family: -apple-system, sans-serif; }
        #root { width: 100vw; height: 100vh; }
        .overlay { position: absolute; top: 10%; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
        .overlay h1 { color: #FFFACD; text-shadow: 0 0 20px rgba(255,250,205,0.8); margin: 0; font-size: 28px; }
        .overlay p { color: white; opacity: 0.6; letter-spacing: 5px; font-size: 12px; margin-top: 10px; }
        .hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: #C1E1C1; opacity: 0.5; font-size: 11px; letter-spacing: 2px; pointer-events: none; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom": "https://esm.sh/react-dom@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.88.15?external=react,react-dom,three,@react-three/fiber",
            "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.15.11?external=react,react-dom,three,@react-three/fiber"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div class="overlay"><h1 id="greeting"></h1><p>MERRY CHRISTMAS</p></div>
    <div id="root"></div>
    <div class="hint">点击爆发 • 兔子和草莓都在哦</div>

    <script type="text/babel" data-type="module">
        /** @jsx React.createElement */
        /** @jsxFrag React.Fragment */
        import React, { useState, useMemo, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Float, Stars, OrbitControls, PerspectiveCamera } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

        const PALETTE = { green: '#165B33', gold: '#FFD700', silver: '#E5E4E2', xmasRed: '#D42426', pink: '#FFB7B2', bg: '#010403' };

        const Typewriter = () => {
            useEffect(() => {
                const text = "小羊同学，圣诞节快乐！";
                let i = 0;
                const interval = setInterval(() => {
                    const el = document.getElementById('greeting');
                    if(el) el.innerText = text.slice(0, i);
                    i++;
                    if (i > text.length) clearInterval(interval);
                }, 150);
                return () => clearInterval(interval);
            }, []);
            return null;
        };

        // 1. 线条兔子组件 (增加了独立自转)
        const WireRabbitGroup = ({ isExploded }) => {
            const groupRef = useRef();
            const bunnies = useMemo(() => {
                return Array.from({ length: 5 }, (_, i) => ({
                    angle: (i / 5) * Math.PI * 2,
                    y: -4 + Math.random() * 2
                }));
            }, []);

            useFrame((state) => {
                if (!isExploded && groupRef.current) {
                    groupRef.current.rotation.y += 0.005;
                }
            });

            return (
                <group ref={groupRef}>
                    {bunnies.map((b, i) => (
                        <group key={i} position={[Math.cos(b.angle) * 4, b.y, Math.sin(b.angle) * 4]}>
                            <mesh rotation={[0, -b.angle, 0]}>
                                <icosahedronGeometry args={[0.3, 1]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                            {/* 耳朵 */}
                            <mesh position={[0.1, 0.4, 0]} rotation={[0, 0, 0.2]}>
                                <capsuleGeometry args={[0.04, 0.25, 4, 8]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                            <mesh position={[-0.1, 0.4, 0]} rotation={[0, 0, -0.2]}>
                                <capsuleGeometry args={[0.04, 0.25, 4, 8]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                        </group>
                    ))}
                </group>
            );
        };

        // 2. 草莓顶端
        const Strawberry = () => {
            const seeds = useMemo(() => {
                const pts = [];
                for (let i = 0; i < 50; i++) {
                    const phi = Math.acos(-1 + (2 * i) / 50);
                    const theta = Math.sqrt(50 * Math.PI) * phi;
                    pts.push([0.35 * Math.sin(phi) * Math.cos(theta), 0.45 * Math.cos(phi), 0.35 * Math.sin(phi) * Math.sin(theta)]);
                }
                return pts;
            }, []);

            return (
                <Float speed={4} floatIntensity={2}>
                    <group position={[0, 5.5, 0]} scale={1.2}>
                        <mesh>
                            <sphereGeometry args={[0.4, 20, 20]} />
                            <meshStandardMaterial color="#FF0800" roughness={0.3} emissive="#400000" />
                        </mesh>
                        {seeds.map((pos, i) => (
                            <mesh key={i} position={pos}>
                                <sphereGeometry args={[0.015, 4, 4]} />
                                <meshBasicMaterial color="#1a0000" />
                            </mesh>
                        ))}
                        <group position={[0, 0.35, 0]}>
                            {[0, 1, 2, 3, 4].map((i) => (
                                <mesh key={i} rotation={[0, (i * Math.PI * 2) / 5, 0.4]}>
                                    <capsuleGeometry args={[0.05, 0.25, 4, 8]} />
                                    <meshStandardMaterial color="#228B22" />
                                </mesh>
                            ))}
                        </group>
                        <pointLight intensity={10} color="#FF0800" />
                    </group>
                </Float>
            );
        };

        // 3. 松针层次树体
        const NeedleTree = ({ isExploded }) => {
            const count = 5500;
            const meshRef = useRef();
            const [positions, lineData] = useMemo(() => {
                const posArr = new Float32Array(count * 3);
                const baseArr = new Float32Array(count * 3);
                const vels = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 1.1) * 10 - 5;
                    const r = (5 - y) * 0.42;
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    posArr.set([x, y, z], i * 3);
                    baseArr.set([x, y, z], i * 3);
                    const v = new THREE.Vector3(x, y, z).normalize().multiplyScalar(Math.random() * 10 + 5);
                    vels.set([v.x, v.y, v.z], i * 3);
                }
                return [posArr, { baseArr, vels }];
            }, []);

            useFrame((state, delta) => {
                const attr = meshRef.current.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    let x = attr.array[i*3], y = attr.array[i*3+1], z = attr.array[i*3+2];
                    if (isExploded) {
                        x += lineData.vels[i*3] * delta; 
                        y += lineData.vels[i*3+1] * delta; 
                        z += lineData.vels[i*3+2] * delta;
                    } else {
                        x = THREE.MathUtils.lerp(x, lineData.baseArr[i*3], 0.1);
                        y = THREE.MathUtils.lerp(y, lineData.baseArr[i*3+1], 0.1);
                        z = THREE.MathUtils.lerp(z, lineData.baseArr[i*3+2], 0.1);
                    }
                    attr.setXYZ(i, x, y, z);
                }
                attr.needsUpdate = true;
            });

            return (
                <points ref={meshRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={positions} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.07} color="#165B33" transparent opacity={0.7} blending={THREE.AdditiveBlending} />
                </points>
            );
        };

        // 4. 金属球
        const MetallicOrbs = ({ isExploded }) => {
            const meshRef = useRef();
            const dummy = new THREE.Object3D();
            const count = 40;
            const colors = [PALETTE.gold, PALETTE.silver, PALETTE.xmasRed, '#FF69B4'];
            const orbs = useMemo(() => Array.from({ length: count }, (_, i) => {
                const y = Math.pow(Math.random(), 0.9) * 9 - 4.5;
                const r = (5 - y) * 0.4;
                const angle = Math.random() * Math.PI * 2;
                const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
                return { base: pos.clone(), curr: pos.clone(), vel: pos.clone().normalize().multiplyScalar(15), col: new THREE.Color(colors[i%4]) };
            }), []);

            useFrame((state, delta) => {
                orbs.forEach((o, i) => {
                    if (isExploded) o.curr.addScaledVector(o.vel, delta);
                    else o.curr.lerp(o.base, 0.1);
                    dummy.position.copy(o.curr);
                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i, dummy.matrix);
                    meshRef.current.setColorAt(i, o.col);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
                meshRef.current.instanceColor.needsUpdate = true;
            });

            return (
                <instancedMesh ref={meshRef} args={[new THREE.SphereGeometry(0.14, 20, 20), null, count]}>
                    <meshStandardMaterial metalness={1} roughness={0.1} />
                </instancedMesh>
            );
        };

        const App = () => {
            const [exploded, setExploded] = useState(false);
            return (
                <Canvas onClick={() => setExploded(!exploded)}>
                    <Typewriter />
                    <PerspectiveCamera makeDefault position={[0, 2, 16]} fov={45} />
                    <OrbitControls enablePan={false} autoRotate={!exploded} />
                    <color attach="background" args={[PALETTE.bg]} />
                    <ambientLight intensity={0.6} />
                    <pointLight position={[10, 10, 10]} intensity={15} color={PALETTE.gold} />
                    <Stars radius={100} depth={50} count={3000} factor={4} fade />
                    
                    <NeedleTree isExploded={exploded} />
                    <MetallicOrbs isExploded={exploded} />
                    <WireRabbitGroup isExploded={exploded} />
                    <Strawberry />

                    <EffectComposer>
                        <Bloom luminanceThreshold={0.2} mipmapBlur intensity={1.5} />
                        <Vignette darkness={1.2} />
                    </EffectComposer>
                </Canvas>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
